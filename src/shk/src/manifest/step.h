#pragma once

#include <string>
#include <vector>

#include "hash.h"
#include "optional.h"
#include "fs/path.h"
#include "manifest/raw_step.h"

namespace shk {

/**
 * A Step is a dumb data object that represents one build statment in the
 * build manifest.
 *
 * Parsing the build manifest and evaluating the rules results in a list of
 * Step objects. When the Steps object have been created, the manifest and the
 * variable environments etc can be discarded. It is not possible to recreate
 * the manifest from the list of steps; Step objects contain already evaluated
 * commands.
 */
struct Step {
  class Builder {
   public:
    Builder &setInputs(std::vector<Path> &&inputs);
    Builder &setImplicitInputs(std::vector<Path> &&implicit_inputs);
    Builder &setDependencies(std::vector<Path> &&dependencies);
    Builder &setOutputs(std::vector<Path> &&outputs);
    Builder &setPoolName(std::string &&pool_name);
    Builder &setCommand(std::string &&command);
    Builder &setDescription(std::string &&description);
    Builder &setGenerator(bool &&generator);
    Builder &setDepfile(Optional<Path> &&depfile);
    Builder &setRspfile(Optional<Path> &&rspfile);
    Builder &setRspfileContent(std::string &&rspfile_content);

    Step build();

   private:
    std::vector<Path> _inputs;
    std::vector<Path> _implicit_inputs;
    std::vector<Path> _dependencies;
    std::vector<Path> _outputs;
    std::string _pool_name;
    std::string _command;
    std::string _description;
    bool _generator = false;
    Optional<Path> _depfile;
    Optional<Path> _rspfile;
    std::string _rspfile_content;
  };

  /**
   * Builder is recommended to use over this constructor.
   */
  Step(
      std::vector<Path> &&inputs,
      std::vector<Path> &&implicit_inputs,
      std::vector<Path> &&dependencies,
      std::vector<Path> &&outputs,
      std::string &&pool_name,
      std::string &&command,
      std::string &&description,
      bool &&generator,
      Optional<Path> &&depfile,
      Optional<Path> &&rspfile,
      std::string &&rspfile_content);
  Step();
  Step(RawStep &&step);

  /**
   * Input files, as specified in the manifest. These, together with the
   * implicit dependencies are files that the build step is expected to read
   * from directly.
   */
  std::vector<Path> inputs;

  /**
   * Input files, as specified in the manifest. Like inputs, but the implicit
   * dependencies are not part of the $in and $in_newline variables. Once the
   * manifest has been parsed into Steps objects like these, there isn't really
   * much of a difference between inputs and implicit dependencies.
   */
  std::vector<Path> implicit_inputs;

  /**
   * Dependencies are paths to targets that generate output files that this
   * target may depend on. These are different from inputs because they
   * themselves are often not read by the build step. A common use case for this
   * is targets that generate headers that other targets may depend on.
   *
   * These correspond to "order only" dependencies in the Ninja manifest.
   *
   * dependencies and inputs are kept separate because persistent caching cares
   * about the difference.
   */
  std::vector<Path> dependencies;

  /**
   * Output files, as specified in the manifest. These are used as names for
   * targets, to deduce the dependencies between different build steps and to
   * make sure that the directory where the outputs should live exists before
   * the command is invoked.
   */
  std::vector<Path> outputs;

  std::string pool_name;

  /**
   * Command that should be invoked in order to perform this build step.
   *
   * The command string is empty for phony rules.
   */
  std::string command;

  /**
   * A short description of the command. Used for prettifying output while
   * running builds.
   */
  std::string description;

  bool phony() const {
    return command.empty();
  }

  /**
   * It set to true, Shuriken will treat this build step as one that rewrites
   * manifest files. They are treated specially in the following ways:
   *
   * * They are not rebuilt if the command line changes
   * * Files are checked for dirtiness via mtime checks rather than file hashes
   * * They are not cleaned
   */
  bool generator = false;

  /**
   * For compatibility reasons with Ninja, Shuriken keeps track of the path to
   * a potential depfile generated by the build steps. Shuriken does not use
   * this file, it just removes it immediately after the build step has
   * completed.
   */
  Optional<Path> depfile;

  /**
   * If rspfile is not empty, Shuriken will write rspfile_content to the path
   * specified by rspfile before running the build step and then remove the file
   * after the build step has finished running. Useful on Windows, where
   * commands have a rather short maximum length.
   */
  Optional<Path> rspfile;
  std::string rspfile_content;

  Hash hash() const;
};

inline bool isConsolePool(const std::string &pool_name) {
  return pool_name == "console";
}

}  // namespace shk
