https://capnproto.org/language.html
https://blake2.net/
https://www.schneier.com/cryptography/skein/
https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt
https://github.com/bazelbuild/bazel/blob/master/tools/cpp/CROSSTOOL
https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds
https://codereview.chromium.org/699083004
CppCompileAction.java options.add("-frandom-seed=" + outputFile.getExecPathString());
https://lwn.net/Articles/630074/
https://wiki.debian.org/ReproducibleBuilds/Howto
https://github.com/sevki/build

https://github.com/apenwarr/redo#readme
http://cr.yp.to/redo/honest-script.html

Differences from Ninja:
* Dependencies of builds steps that have been run are deduced from the files that the build
  step read instead of relying on the information in the manifest. (mscv_deps_prefix, deps
  and depfile are ignored, other than that the .d file is removed)
* File hashes are used rather than mtimes (except for generator rules, they still use mtimes)
* msvc_deps_prefix, deps, depfile are unnecessary (except that the .d file should be removed)
* Supports multiple outputs even when deps is specified.
* When the console pool is used, the command is always rebuilt. Reason being
  stdin is not a deterministic source, and it tends to be used for things as tests
  and generator rules anyway.
* Does not fail the build on missing inputs.
* Commands run have only very limited exposure to environment variables

Missing features:
* spell checking on target file names
* browse
* urtle

Errors that Shuriken does not detect:
* Nondeterministic problems in invoked build steps
* Build steps whose output depend on certain files *missing*
* Build steps that read from or append to an output file
* Build steps that depend on the contents of system wide folders such as
  /etc, /tmp, /Applications.

Build steps in Shuriken must fulfill the following requirements:
* Must be a pure function; given the same input must generate the same output
* The output must be written only as files and output to stdin/stderr
* The input must be read only from the file system, from the command line and from
  environment variables. This means that input must not come from stdin, network, other
  processes, devices etc. Ideally it should also not depend on time or randomness.
* Must not modify input files. This also includes that input files must not be moved.
  (Every file that the build step did not create is an input file.)
* When inputs are outputs of other build steps, those must be declared as dependencies.
* When the command of the build step returns, all of the processes it created must be dead.


The manifest must fulfill the following requirements:
* There must not be more than one build step that generates any given output file
* No cyclic dependencies


Steps of a Shuriken build:
* Read the manifest file, build Manifest graph, which contains
  - All build steps:
    - Other build steps that (order-only) depend on this build step
    - Command line invocation
    - bool restat
* Read the invocation log, which contains
  - All build invocations that have been successfully run:
    - Output files fingerprints
    - Inputs (fingerprints, but also make sure to handle the access syscall)
    - (Hash of) the build step that the invocation is based on

* Find build invocations that no longer exist in the Manifest graph
  - Remove the outputs
* Find build invocations that are dirty
  - Verify input and output fingerprints
* Find build steps that have no corresponding build invocation

* Construct Tasks graph:
  - From dirty invocations and build steps that don't have an invocation
  - Each task contains
    - Command line invocation
    - Output file fingerprints of prior build invocation (if any)
    - bool restat
    - Other tasks that depend on this one
    - The number of tasks that this task depends on
      - Decremented if a restat task changes nothing
      - The command is not run if the number is zero

* Execute Tasks graph:
  - Invoke commands in parallel
    - Restrict env vars
  - Lint
    - Check that there are no files that are generated by more than one invocation (lint the manifest)
    - Check that there are no cyclic dependencies in the manifest
    - Check that all input files except for phony targets exist
    - File system access
      - Do not read outputs
      - Do not modify inputs (move or change contents)
      - Input files that are outputs of other build invocations are
        declared as dependencies. (How to do this efficiently?)
      - Declared outputs that other rules depend on as inputs are created
      - No outputs that other build steps have already created are created
      - No outputs that other build steps have as declared outputs are created
    - Disallowed syscalls
    - Detect and reject daemons
  - When a command is done
    - delete stale outputs
    - record data in the invocation log

* Try reduce number of /bin/sh invocations per command. I think it's 3 now
* Path stuff
  - normalization of paths
  - case (in)sensitivity?
    http://www.opensource.apple.com/source/xnu/xnu-2050.18.24/bsd/hfs/hfs_vfsutils.c?txt
  - perhaps ditch canonicalization and use st_dev/st_ino instead.
- Fingerprint stuff
* Hashing function
* Functionality to parse and write to the invocation log
- Function to delete outputs
* Function to detect insufficiently declared dependencies (how to do this?)

Path:
* Is a (st_ino, st_dev) tuple + canonicalized path under it (interned)
* A path can be 1 machine word, if the interned string also has the stat data
* Canonicalization consists of both normalizing .. and . and //s and canonicalizing
  + case folding the string itself.
* All directories within the canonicalized path must be real directories, not symlinks
* Need to detect and fail on directories that would have been created to do the
  build that are hard links to each other.
* Things to make sure
  - No two Paths that case fold/normalize to the same path but have different non
    case folded/normalized representations.

Things to do for increased build correctness:
* Keep a map from (st_dev, st_ino) => Path. Whenever a directory is created because
  it was missing when the build started, and it turns out that it has already been
  created by someone else, make sure that its (st_dev, st_ino) is not the same as
  some other path that we have seen. That means hardlink and could break the build.
* Validate that the command did not read a file that is an output
  of a target that it does not depend on directly or indirectly.

Large things remaining to do:
* The reported number of run commands is jumpy and does not update every time
* Error when building core: "shk: fatal: pipe: Too many open files"
* Deal with depfile files: Delete them and don't treat them as outputs
* Ensure sufficient parallelism. Seems like it doesn't always invoke as many commands
  as it can.
* Ocasionally recompact
* Unit test shk::build
* Handle restat rules
* Handle build pools
* detail::deleteOldOutputs
* detail::deleteStaleOutputs
* Stat cache for use by Paths
* Rebuild manifest
* There seems to be a race in TracingCommandRunner. It doesn't always catch deps
* CLI tools:
  * clean
  * commands
  * graph (graphviz)
  * query
  * targets
  * compdb
  * recompact
* Shield commands from env vars
* Caching
* Distributed caching

* Possible optimizations
  * Avoid the excessive duplication in the Invocations data structure by using shared_ptr
    to const or smt
  * Avoid the excessive stat-ing by using a stat cache pre-build
  * Avoid the excessive fingerprint duplications in the invocation log by remembering
    previous fingerprints somehow. Stat cache or otherwise.

* Make sure the build does the right thing even if targets are specified wrong on the command line
* Hash symlinks in a special way (see fingerprintStat)
* Unit test BuildStatus
* Write documentation
* Fuzz test parsers (invocation log, sandbox, manifest)
* Path case folding
* See if adding HAVE_SSSE3, HAVE_XOP, HAVE_SSE41 etc flags for blake2 makes sense
* Optimization opportunity: Don't calculate hashes twice for racily clean files
* Check test coverage and add missing unit tests

To fill in the first test:
* Generate actual DAG in gen::buildInput
* Add assertions to the property

Steal directly from Ninja:
* Stat cache for Windows
* getopt (for Windows only)
